import os
import sys
import requests
import pandas as pd
import xlwings as xw
import argparse
import time
from datetime import datetime, timedelta
from dateutil.parser import parse

# Пути и константы
desktop_path = os.path.join(os.path.expanduser("~"), "Desktop")
excel_file = os.path.join(desktop_path, "Отгрузка.xlsx")
MAX_RETRIES = 3
RETRY_DELAY = 5
REQUEST_TIMEOUT = 120

URL_PARAMS = {
    "remains_rpkd_domodedovo": {
        "base_url": 'https://wms.vseinstrumenti.ru/Report/repProductForInternalPurchase/generate',
        "type": 'remains_rpkd_domodedovo', "source": "Домодедово"},
    "remains_rpkd_chashnikovo": {
        "base_url": 'https://wms.vseinstrumenti.ru/Report/repProductForInternalPurchase/generate',
        "type": 'remains_rpkd_chashnikovo', "source": "Чашниково"},
    "remains_to_complete": {"base_url": 'https://wms.vseinstrumenti.ru/Report/repProductRest/generate',
                            "type": 'remains_to_complete'},
    "remains_for_selection": {"base_url": 'https://wms.vseinstrumenti.ru/Report/repTaskControl/generate',
                              "type": 'remains_for_selection'},
    "movement_rpkd": {"base_url": 'https://wms.vseinstrumenti.ru/Report/repMovement/generate', "type": 'movement_rpkd'},
    "movement_shops_regions": {"base_url": 'https://wms.vseinstrumenti.ru/Report/repMovement/generate',
                               "type": 'movement_shops_regions'},
    "container_close_rpkd": {"base_url": 'https://wms.vseinstrumenti.ru/Report/repMovement/generate',
                             "type": 'container_close_rpkd'},
    "container_close_shops_regions": {"base_url": 'https://wms.vseinstrumenti.ru/Report/repMovement/generate',
                                      "type": 'container_close_shops_regions'},
    "picking": {"base_url": 'https://wms.vseinstrumenti.ru/Report/repMovement/generate', "type": 'picking'}
}

OPERATION_CLASSES = {
    "Отстатки_РПКД_Домодедово": "remains_rpkd_domodedovo",
    "Отстатки_РПКД_Чашниково": "remains_rpkd_chashnikovo",
    "Осталось_Закомплектовать": "remains_to_complete",
    "Осталось_На_Отборе": "remains_for_selection",
    "Комплектация_РПКД": "movement_rpkd",
    "Комплектация_Магазы_Реги": "movement_shops_regions",
    "Закрытие_контейнера_РПКД": "container_close_rpkd",
    "Закрытие_контейнера_Магазы_Реги": "container_close_shops_regions",
    "Сделано_Отбор": "picking"
}

SHEETS_WITH_KOMPLEKTACIYA = ["Осталось_Закомплектовать", "Комплектация_РПКД", "Комплектация_Магазы_Реги"]
def convert_to_numeric_columns(df, columns):
    """
    Для каждого имени в columns, если есть в df — заменяет запятые на точки,
    приводит к числу и заполняет NaN нулями.
    """
    for col in columns:
        if col in df.columns:
            if pd.api.types.is_string_dtype(df[col]):
                df[col] = pd.to_numeric(df[col].str.replace(",", "."), errors="coerce").fillna(0)
            else:
                df[col] = pd.to_numeric(df[col], errors="coerce").fillna(0)


# Новая функция для записи времени в лист "Главная", ячейка K2
def write_current_time_to_main(excel_file):
    current_time = datetime.now().strftime("%H:%M")
    try:
        wb = None
        # Ищем открытую книгу с именем, соответствующим заданному пути
        for book in xw.books:
            if os.path.basename(book.fullname).lower() == os.path.basename(excel_file).lower():
                wb = book
                break
        if wb is None:
            print(f"Книга {excel_file} не найдена среди открытых. Попытка открыть книгу.")
            wb = xw.Book(excel_file)
        if "Главная" in [sheet.name for sheet in wb.sheets]:
            wb.sheets["Главная"].range("K2").value = current_time
            wb.save()  # сохраняем изменения
            print(f"Записано текущее время {current_time} в лист 'Главная', ячейка K2")
        else:
            print("Лист 'Главная' не найден в книге. Время не записано.")
    except Exception as e:
        print(f"Ошибка при записи времени в Excel: {e}")


def read_excel_data_xlwings(fname, sheet):
    if not os.path.exists(fname):
        raise FileNotFoundError(f"File '{fname}' not found on desktop")
    app = xw.App(visible=False)
    wb = app.books.open(fname)
    sheet_exists = any(sh.name == sheet for sh in wb.sheets)
    if not sheet_exists:
        wb.close()
        app.quit()
        print(f"Лист '{sheet}' не найден в файле")
        return []
    sh = wb.sheets[sheet]
    was_hidden = sh.api.Visible == 0
    if was_hidden:
        sh.api.Visible = -1
    values = sh.range("A1").expand("table").value
    if was_hidden:
        sh.api.Visible = 0
    wb.close()
    app.quit()
    cleaned_values = [row for row in values if any(cell is not None and str(cell).strip() for cell in row)]
    return cleaned_values if cleaned_values else values


def get_credentials_and_date(fname, sheet):
    if not os.path.exists(fname):
        raise FileNotFoundError(f"File '{fname}' not found on desktop")
    df = pd.read_excel(fname, sheet_name=sheet, engine='openpyxl', header=None)
    username, password = df.iloc[0, 1], df.iloc[1, 1]
    date_str = df.iloc[4, 1] if not pd.isna(df.iloc[4, 1]) else ""
    if not date_str or pd.isna(date_str) or str(date_str).strip() == "":
        date_str = datetime.now().strftime("%d.%m.%Y")
    else:
        try:
            date_obj = parse(str(date_str), dayfirst=True, fuzzy=True)
            date_str = date_obj.strftime("%d.%m.%Y")
        except (ValueError, TypeError):
            date_str = datetime.now().strftime("%d.%m.%Y")
    return username, password, date_str


def load_dict(fname, sheet):
    data = read_excel_data_xlwings(fname, sheet)
    return {row[0]: row[1] for row in data if len(row) >= 2 and row[0] is not None}


def load_rates(fname):
    try:
        data = read_excel_data_xlwings(fname, "Ставки")
        rates = {}
        container_close_rate = 0.0
        if data and len(data) >= 7 and len(data[6]) >= 2:
            try:
                container_close_rate = float(str(data[6][1]).replace(",", "."))
                print(f"Загружена ставка Закрытие контейнера: {container_close_rate}")
            except (ValueError, TypeError, IndexError):
                print("Не удалось загрузить ставку Закрытие контейнера, используется 0.0")
        rates["container_close_rate"] = container_close_rate
        if data and len(data) > 0:
            header = data[0]
            ставка_отбор_idx = None
            ставка_комплектация_idx = None
            for i, col in enumerate(header):
                if col == "Ставка_Отбор":
                    ставка_отбор_idx = i
                elif col == "Ставка_Комплектация":
                    ставка_комплектация_idx = i
            if ставка_отбор_idx is not None:
                for i in range(1, len(data)):
                    row = data[i]
                    if row and len(row) > ставка_отбор_idx and row[0]:
                        model_zone = str(row[0]).strip()
                        try:
                            rates[model_zone] = float(str(row[ставка_отбор_idx]).replace(",", "."))
                        except (ValueError, TypeError):
                            rates[model_zone] = 0.0
            if ставка_комплектация_idx is not None:
                комплектация_rates = {}
                for i in range(1, len(data)):
                    row = data[i]
                    if row and len(row) > ставка_комплектация_idx and row[0]:
                        model_zone = str(row[0]).strip()
                        try:
                            комплектация_rates[model_zone] = float(str(row[ставка_комплектация_idx]).replace(",", "."))
                        except (ValueError, TypeError):
                            комплектация_rates[model_zone] = 0.0
                rates['комплектация_rates'] = комплектация_rates
                print(f"Загружены ставки комплектации для {len(комплектация_rates)} моделей")
        print(f"Загружены ставки для {len(rates) - 1 - ('комплектация_rates' in rates)} типов моделей зон")
        return rates
    except Exception as e:
        print(f"Ошибка при загрузке ставок: {e}")
        return {"container_close_rate": 0.0}


def load_zones_dict(fname):
    try:
        data = read_excel_data_xlwings(fname, "Зоны")
        zones_dict = {}
        if data and len(data) > 0:
            for i in range(1, len(data)):
                row = data[i]
                if len(row) >= 2:
                    source_zone = str(row[0]).strip()
                    model_zone = str(row[1]).strip()
                    if source_zone and model_zone:
                        zones_dict[source_zone] = model_zone
                        zones_dict[source_zone.lower()] = model_zone
                        normalized = ' '.join(source_zone.split())
                        zones_dict[normalized] = model_zone
                        clean_zone = source_zone.replace("(А)", "(A)").strip()
                        zones_dict[clean_zone] = model_zone
                        if "(A)" in clean_zone or "(А)" in source_zone:
                            alt_zone = source_zone.replace("(А)", "").replace("(A)", "").strip()
                            zones_dict[alt_zone] = model_zone
                            zones_dict[alt_zone.lower()] = model_zone
                        dash_normalized = source_zone.replace("–", "-").replace("—", "-")
                        if dash_normalized != source_zone:
                            zones_dict[dash_normalized] = model_zone
        return zones_dict
    except Exception as e:
        print(f"Ошибка при загрузке словаря зон: {e}")
        return {}


def authenticate(u, p):
    s = requests.Session()
    s.headers.update({
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Accept-Language': 'ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7'
    })
    print(f"Выполняем аутентификацию с логином: {u}")
    auth_data = {"FormLogin[username]": u, "FormLogin[password]": p}
    for attempt in range(MAX_RETRIES):
        try:
            r = s.post('https://wms.vseinstrumenti.ru/site/login', data=auth_data, timeout=REQUEST_TIMEOUT)
            if r.status_code != 200:
                if attempt < MAX_RETRIES - 1:
                    time.sleep(RETRY_DELAY)
                    continue
                else:
                    raise Exception("Ошибка авторизации после нескольких попыток")
            print("Аутентификация выполнена успешно")
            return s
        except requests.exceptions.RequestException as e:
            if attempt < MAX_RETRIES - 1:
                time.sleep(RETRY_DELAY)
            else:
                raise Exception(f"Не удалось выполнить аутентификацию после {MAX_RETRIES} попыток: {e}")


def write_excel(bname, sheet, df):
    try:
        if xw.apps.count == 0:
            app = xw.App(visible=True)
        else:
            app = xw.apps.active
        wb = next((b for b in app.books if b.name.lower() == os.path.basename(bname).lower()), None)
        if not wb:
            try:
                wb = app.books.open(bname)
            except Exception as e:
                temp_fname = os.path.join(desktop_path, "Отгрузка_temp.xlsx")
                if os.path.exists(temp_fname):
                    os.remove(temp_fname)
                wb = app.books.add()
                wb.save(temp_fname)
                wb.close()
                app.quit()
                app = xw.App(visible=True)
                wb = app.books.open(temp_fname)
                bname = temp_fname
        if sheet not in [s.name for s in wb.sheets]:
            wb.sheets.add(sheet)
        sh = wb.sheets[sheet]
        try:
            sh.clear_contents()
        except:
            sh.clear()
        sh.range("A1").value = df
        wb.save(bname)
    except Exception as e:
        print(f"Error writing to Excel: {e}")
        raise


def download_file_with_retry(sess, url, operation_name):
    for attempt in range(MAX_RETRIES):
        try:
            r = sess.get(url, timeout=REQUEST_TIMEOUT)
            if r.status_code != 200:
                if attempt < MAX_RETRIES - 1:
                    time.sleep(RETRY_DELAY)
                    continue
                else:
                    raise Exception(f"Ошибка загрузки данных после {MAX_RETRIES} попыток, статус код: {r.status_code}")
            return r
        except requests.exceptions.RequestException as e:
            if attempt < MAX_RETRIES - 1:
                time.sleep(RETRY_DELAY * (attempt + 1))
            else:
                raise Exception(f"Не удалось загрузить данные после {MAX_RETRIES} попыток: {e}")


def update_dates(url, date_str, operation_type=None):
    try:
        print(f"Обрабатываю дату: '{date_str}' для операции: {operation_type}")
        try:
            date_obj = datetime.strptime(date_str, "%d.%m.%Y")
        except ValueError:
            date_obj = parse(date_str, dayfirst=True)
        d1 = date_obj.strftime("%d.%m.%Y")
        d2 = date_obj.strftime("%Y-%m-%d")
        next_day_obj = date_obj + timedelta(days=1)
        next_d1 = next_day_obj.strftime("%d.%m.%Y")
        next_d2 = next_day_obj.strftime("%Y-%m-%d")
        print(f"Преобразовано в формат d1: {d1}, d2: {d2}")
        print(f"Следующий день: next_d1: {next_d1}, next_d2: {next_d2}")
        if operation_type == "picking":
            url = url.replace("2025-03-27+10%3A00%3A00", f"{d2}+10%3A00%3A00")
            url = url.replace("27.03.2025+10%3A00%3A00", f"{d1}+10%3A00%3A00")
            url = url.replace("2025-03-27+23%3A59%3A59", f"{d2}+23%3A59%3A59")
            url = url.replace("27.03.2025+23%3A59%3A59", f"{d1}+23%3A59%3A59")
        elif operation_type in ["remains_rpkd_domodedovo", "remains_rpkd_chashnikovo"]:
            url = url.replace("2025-03-18+08%3A00%3A00", f"{d2}+08%3A00%3A00")
            url = url.replace("18.03.2025+08%3A00%3A00", f"{d1}+08%3A00%3A00")
            url = url.replace("2025-03-18+12%3A00%3A00", f"{d2}+12%3A00%3A00")
            url = url.replace("18.03.2025+12%3A00%3A00", f"{d1}+12%3A00%3A00")
        elif operation_type == "remains_to_complete":
            url = url.replace("2025-03-18", d2)
            url = url.replace("18.03.2025", d1)
        elif operation_type == "remains_for_selection":
            url = url.replace("2025-03-18+14%3A32%3A31", f"{d2}+14%3A32%3A31")
            url = url.replace("2025-03-18", d2)
            url = url.replace("18.03.2025", d1)
            url = url.replace("2025-03-19", next_d2)
            url = url.replace("19.03.2025", next_d1)
            url = url.replace("2025-03-18+00%3A00%3A00", f"{d2}+00%3A00%3A00")
            url = url.replace("2025-03-19+00%3A00%3A00", f"{next_d2}+00%3A00%3A00")
        elif operation_type in ["movement_rpkd", "movement_shops_regions", "container_close_rpkd",
                                "container_close_shops_regions"]:
            url = url.replace("2025-03-25+10%3A00%3A00", f"{d2}+10%3A00%3A00")
            url = url.replace("25.03.2025+10%3A00%3A00", f"{d1}+10%3A00%3A00")
            url = url.replace("2025-03-25+23%3A59%3A59", f"{d2}+23%3A59%3A59")
            url = url.replace("25.03.2025+23%3A59%3A59", f"{d1}+23%3A59%3A59")
        return url
    except Exception as e:
        print(f"Ошибка при обработке даты '{date_str}': {e}")
        raise ValueError("Invalid date format. Use DD.MM.YYYY, for example, 24.02.2025")


def add_operation_and_calculate_costs(df, sheet_name, rates, zones_dict=None, model5_dict=None):
    if sheet_name == "Сделано_Отбор":
        df['Операция'] = 'Отбор'
        df['В деньгах'] = 0.0
        if zones_dict is not None and ('source_zone_name' in df.columns or 'Исходная зона' in df.columns):
            zone_col = 'source_zone_name' if 'source_zone_name' in df.columns else 'Исходная зона'
            def map_zone(source_zone):
                if pd.isna(source_zone): return 'Нет соответствия'
                source_zone = str(source_zone).strip()
                if source_zone in zones_dict: return zones_dict[source_zone]
                if source_zone.lower() in zones_dict: return zones_dict[source_zone.lower()]
                normalized = ' '.join(source_zone.split())
                if normalized in zones_dict: return zones_dict[normalized]
                no_brackets = source_zone.replace("(А)", "").replace("(A)", "").strip()
                if no_brackets in zones_dict: return zones_dict[no_brackets]
                dash_normalized = source_zone.replace("–", "-").replace("—", "-")
                if dash_normalized in zones_dict: return zones_dict[dash_normalized]
                return 'Нет соответствия'
            df['Зона'] = df[zone_col].apply(map_zone)
            if '5 моделей учёта' in df.columns:
                for idx, row in df.iterrows():
                    zone_model = row['Зона'] if row['Зона'] != 'Нет соответствия' else ''
                    model5 = row['5 моделей учёта'] if not pd.isna(row['5 моделей учёта']) else ''
                    if zone_model and model5:
                        model_zone = f"{zone_model}_{model5}"
                        df.at[idx, 'Модель зоны'] = model_zone
                        if model_zone in rates:
                            df.at[idx, 'В деньгах'] = rates[model_zone]
                        else:
                            df.at[idx, 'В деньгах'] = 0.0
                            print(f"Не найдена ставка для модели зоны: {model_zone}")
                    else:
                        df.at[idx, 'Модель зоны'] = 'Нет соответствия'
                        df.at[idx, 'В деньгах'] = 0.0
    elif sheet_name in ["Закрытие_контейнера_Магазы_Реги", "Закрытие_контейнера_РПКД"]:
        df['Операция'] = 'Закрытие контейнера'
        container_close_rate = rates.get("container_close_rate", 0.0)
        df['В деньгах'] = container_close_rate
        print(f"Установлена ставка {container_close_rate} руб. для операций закрытия контейнера")
    elif sheet_name in SHEETS_WITH_KOMPLEKTACIYA:
        df['Операция'] = 'Комплектация'
        df['В деньгах'] = 0.0
        quantity_col = 'Кол-во' if 'Кол-во' in df.columns else ('Количество' if 'Количество' in df.columns else None)
        if quantity_col and '5 моделей учёта' in df.columns and rates:
            комплектация_rates = {}
            if 'комплектация_rates' in rates and isinstance(rates['комплектация_rates'], dict):
                комплектация_rates = rates['комплектация_rates']
            for idx, row in df.iterrows():
                model = row['5 моделей учёта'] if not pd.isna(row['5 моделей учёта']) else 'Нет соответствия'
                quantity = row[quantity_col] if not pd.isna(row[quantity_col]) else 0
                rate = 0.0
                if model in комплектация_rates:
                    rate = комплектация_rates[model]
                elif model in rates:
                    if isinstance(rates[model], dict) and 'Комплектация' in rates[model]:
                        rate = rates[model]['Комплектация']
                    elif isinstance(rates[model], (int, float)):
                        rate = rates[model]
                df.at[idx, 'В деньгах'] = rate * quantity
    return df


def download_and_process_csv(url, operation_type, sess, model_dict=None, model5_dict=None, rates=None, zones_dict=None):
    r = download_file_with_retry(sess, url, operation_type)
    csv_path = f'temp_{operation_type}.csv'
    with open(csv_path, 'wb') as f:
        f.write(r.content)
    df = pd.read_csv(csv_path, sep=';', encoding='utf-8')
    if operation_type == "picking":
        df = df.rename(columns={
            'movement_datetime': 'Дата перемещения', 'nomenclature_name': 'Номенклатура',
            'quantity': 'Количество', 'executor_name': 'Исполнитель',
            'accounting_model_name': 'Модель учета', 'accounting_model': 'Модель учета',
            'source_zone_name': 'Исходная зона', 'target_zone_name': 'Целевая зона'
        }, errors='ignore')
        for col in ['Количество', 'Кол-во', 'quantity']:
            if col in df.columns:
                if pd.api.types.is_string_dtype(df[col]):
                    df[col] = pd.to_numeric(df[col].str.replace(',', '.'), errors='coerce').fillna(0)
                elif not pd.api.types.is_numeric_dtype(df[col]):
                    df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)
        if model_dict and 'Модель учета' in df.columns:
            df['Товар или РМ'] = df['Модель учета'].map(model_dict).fillna('Товар')
        if model5_dict and 'Модель учета' in df.columns:
            df['5 моделей учёта'] = df['Модель учета'].map(model5_dict).fillna('Нет соответствия')
    elif operation_type in ["remains_rpkd_domodedovo", "remains_rpkd_chashnikovo"]:
        source_warehouse = URL_PARAMS[operation_type]["source"]
        df['Склад источник'] = source_warehouse
        df = df.rename(columns={
            'quantity': 'Количество', 'nomenclature_name': 'Номенклатура',
            'purchase_price': 'Закупочная цена', 'movement_id': 'ID перемещения',
            'accounting_model_name': 'Модель учета', 'accounting_model': 'Модель учета',
            'base_zone_name': 'Базовая зона', 'source_zone_name': 'Исходная зона',
            'target_zone_name': 'Целевая зона', 'executor_name': 'Исполнитель'
        }, errors='ignore')
        if 'Количество' in df.columns:
            if pd.api.types.is_string_dtype(df['Количество']):
                df['Количество'] = pd.to_numeric(df['Количество'].str.replace(',', '.'), errors='coerce').fillna(0)
            elif not pd.api.types.is_numeric_dtype(df['Количество']):
                df['Количество'] = pd.to_numeric(df['Количество'], errors='coerce').fillna(0)
        if model_dict and 'Модель учета' in df.columns:
            df['Товар или РМ'] = df['Модель учета'].map(model_dict).fillna('Товар')
        if model5_dict and 'Модель учета' in df.columns:
            df['5 моделей учёта'] = df['Модель учета'].map(model5_dict).fillna('Нет соответствия')
    elif operation_type == "remains_to_complete":
        df = df.rename(columns={
            'quantity': 'Количество', 'zone_name': 'Зона', 'cell_name': 'Ячейка',
            'container_name': 'Контейнер', 'sku_name': 'Артикул', 'quality_name': 'Качество',
            'purchase_price': 'Закупочная цена', 'order_name': 'Заказ', 'accounting_model': 'Модель учета'
        }, errors='ignore')
        for col in ['Количество', 'Кол-во', 'quantity', 'Осталось штук', 'Осталось адресов']:
            if col in df.columns:
                if pd.api.types.is_string_dtype(df[col]):
                    df[col] = pd.to_numeric(df[col].str.replace(',', '.'), errors='coerce').fillna(0).astype(int)
                else:
                    df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0).astype(int)
        if model_dict and 'Модель учета' in df.columns:
            df['Товар или РМ'] = df['Модель учета'].map(model_dict).fillna('Товар')
        if model5_dict and 'Модель учета' in df.columns:
            df['5 моделей учёта'] = df['Модель учета'].map(model5_dict).fillna('Нет соответствия')
    elif operation_type == "remains_for_selection":
        df = df.rename(columns={
            'quantity': 'Количество', 'type_name': 'Тип задания', 'stream_name': 'Поток',
            'rows_count': 'Количество строк', 'comment': 'Комментарий',
            'shipment_order_name': 'Заказ на отгрузку', 'executor_name': 'Исполнитель'
        }, errors='ignore')

        # --- здесь добавляем конвертацию в числа ---
        convert_to_numeric_columns(df, [
            'Количество',  # старый столбец
            'Кол-во',  # запасной вариант
            'Всего строк',  # ваш новый столбец
            'Количество строк',  # переименованный
            'Осталось штук',  # существующие
            'Осталось адресов'
        ])
    elif operation_type in ["movement_rpkd", "movement_shops_regions"]:
        df = df.rename(columns={
            'movement_datetime': 'Дата перемещения', 'nomenclature_name': 'Номенклатура',
            'quantity': 'Количество', 'executor_name': 'Исполнитель',
            'accounting_model_name': 'Модель учета', 'accounting_model': 'Модель учета',
            'target_zone_name': 'Целевая зона', 'shipment_cell_name': 'Ячейка отгрузки',
            'shipment_order_id': 'ID заказа на отгрузку'
        }, errors='ignore')
        for col in ['Количество', 'Кол-во']:
            if col in df.columns:
                if pd.api.types.is_string_dtype(df[col]):
                    df[col] = pd.to_numeric(df[col].str.replace(',', '.'), errors='coerce').fillna(0)
                else:
                    df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)
        if model_dict and 'Модель учета' in df.columns:
            df['Товар или РМ'] = df['Модель учета'].map(model_dict).fillna('Товар')
        if model5_dict and 'Модель учета' in df.columns:
            df['5 моделей учёта'] = df['Модель учета'].map(model5_dict).fillna('Нет соответствия')
    elif operation_type in ["container_close_rpkd", "container_close_shops_regions"]:
        df = df.rename(columns={
            'movement_datetime': 'Дата перемещения', 'executor_name': 'Исполнитель',
            'target_container_name': 'Целевой контейнер'
        }, errors='ignore')
        if 'Целевой контейнер' in df.columns:
            orig_len = len(df)
            df = df.drop_duplicates(subset=['Целевой контейнер'])
            print(f"Удалено {orig_len - len(df)} дубликатов в столбце 'Целевой контейнер'")
    os.remove(csv_path)
    return df


def process_csv_and_save(sheet_name, excel_file, dataframe, rates=None, zones_dict=None, model5_dict=None):
    # 1) Считаем денежные колонки как раньше
    if rates:
        dataframe = add_operation_and_calculate_costs(dataframe, sheet_name, rates, zones_dict, model5_dict)

    # 2) Убираем эту лишнюю конвертацию — она дублирует то же самое, что уже есть выше
    #    И вообще, если даже оставлять, то надо сравнивать с точным именем листа.
    #    Например, если у вас во вкладке Excel стоит "Осталось_На_отборе" (с маленькой «о»), то нужно:
    if sheet_name == "Осталось_На_отборе":  # <- поправили строку
        # здесь по сути ничего не нужно делать, потому что цифры у вас уже числа
        pass

    # 3) Записываем в Excel
    write_excel(excel_file, sheet_name, dataframe)
    return dataframe

def get_remains_rpkd_domodedovo_url():
    return 'https://wms.vseinstrumenti.ru/Report/repProductForInternalPurchase/generate?RepProductForInternalPurchase%5BexportToFile%5D%5Bmethod%5D=&RepProductForInternalPurchase%5BexportToFile%5D%5Bemails%5D%5B%5D=&layout=&RepProductForInternalPurchase%5Bdate_start%5D=2025-03-18+08%3A00%3A00&presentation_RepProductForInternalPurchase%5Bdate_start%5D=18.03.2025+08%3A00%3A00&RepProductForInternalPurchase%5Bdate_end%5D=2025-03-18+12%3A00%3A00&presentation_RepProductForInternalPurchase%5Bdate_end%5D=18.03.2025+12%3A00%3A00&RepProductForInternalPurchase%5Bsource_base_zone%5D=%D0%94%D0%9E%D0%9C%D0%9E%D0%94%D0%95%D0%94%D0%9E%D0%92%D0%9E&RepProductForInternalPurchase%5Bsource_base_zone_type_id%5D=26&RepProductForInternalPurchase%5Bsource_base_zone_id%5D=36407&RepProductForInternalPurchase%5Btarget_base_zone%5D=%D0%A1%D0%9F%D0%91+-+%D0%A0%D0%A6+%D0%A8%D1%83%D1%88%D0%B0%D1%80%D1%8B+%D0%91%D0%B0%D0%B4%D0%B0%D0%B5%D0%B2%D1%81%D0%BA%D0%BE%D0%B5&RepProductForInternalPurchase%5Btarget_base_zone_type_id%5D=26&RepProductForInternalPurchase%5Btarget_base_zone_id%5D=65302&RepProductForInternalPurchase%5Bnomenclature%5D=&RepProductForInternalPurchase%5Bnomenclature_type_id%5D=13&RepProductForInternalPurchase%5Bnomenclature_id%5D=&RepProductForInternalPurchase%5Bsource_container%5D=&RepProductForInternalPurchase%5Bsource_container_type_id%5D=29&RepProductForInternalPurchase%5Bsource_container_id%5D=&RepProductForInternalPurchase%5BneedTasks%5D=&RepProductForInternalPurchase%5BisExcludeTasksInActs%5D=0&RepProductForInternalPurchase%5Bnumber%5D=&RepProductForInternalPurchase%5BpurchaseCell%5D=&RepProductForInternalPurchase%5BpurchaseCellId_type_id%5D=27&RepProductForInternalPurchase%5BpurchaseCellId%5D=&RepProductForInternalPurchase%5Bshipment_order_process_type%5D=&RepProductForInternalPurchase%5Bprint_form%5D=&RepProductForInternalPurchase%5Bis_pdf%5D=&RepProductForInternalPurchase%5Bprint_form%5D=&RepProductForInternalPurchase%5Bis_pdf%5D=&export=true'


def get_remains_rpkd_chashnikovo_url():
    return 'https://wms.vseinstrumenti.ru/Report/repProductForInternalPurchase/generate?RepProductForInternalPurchase%5BexportToFile%5D%5Bmethod%5D=&RepProductForInternalPurchase%5BexportToFile%5D%5Bemails%5D%5B%5D=&layout=&RepProductForInternalPurchase%5Bdate_start%5D=2025-03-18+08%3A00%3A00&presentation_RepProductForInternalPurchase%5Bdate_start%5D=18.03.2025+08%3A00%3A00&RepProductForInternalPurchase%5Bdate_end%5D=2025-03-18+12%3A00%3A00&presentation_RepProductForInternalPurchase%5Bdate_end%5D=18.03.2025+12%3A00%3A00&RepProductForInternalPurchase%5Bsource_base_zone%5D=%D0%A7%D0%90%D0%A8%D0%9D%D0%98%D0%9A%D0%9E%D0%92%D0%9E&RepProductForInternalPurchase%5Bsource_base_zone_type_id%5D=26&RepProductForInternalPurchase%5Bsource_base_zone_id%5D=76804&RepProductForInternalPurchase%5Btarget_base_zone%5D=%D0%A1%D0%9F%D0%91+-+%D0%A0%D0%A6+%D0%A8%D1%83%D1%88%D0%B0%D1%80%D1%8B+%D0%91%D0%B0%D0%B4%D0%B0%D0%B5%D0%B2%D1%81%D0%BA%D0%BE%D0%B5&RepProductForInternalPurchase%5Btarget_base_zone_type_id%5D=26&RepProductForInternalPurchase%5Btarget_base_zone_id%5D=65302&RepProductForInternalPurchase%5Bnomenclature%5D=&RepProductForInternalPurchase%5Bnomenclature_type_id%5D=13&RepProductForInternalPurchase%5Bnomenclature_id%5D=&RepProductForInternalPurchase%5Bsource_container%5D=&RepProductForInternalPurchase%5Bsource_container_type_id%5D=29&RepProductForInternalPurchase%5Bsource_container_id%5D=&RepProductForInternalPurchase%5BneedTasks%5D=&RepProductForInternalPurchase%5BisExcludeTasksInActs%5D=0&RepProductForInternalPurchase%5Bnumber%5D=&RepProductForInternalPurchase%5BpurchaseCell%5D=&RepProductForInternalPurchase%5BpurchaseCellId_type_id%5D=27&RepProductForInternalPurchase%5BpurchaseCellId%5D=&RepProductForInternalPurchase%5Bshipment_order_process_type%5D=&RepProductForInternalPurchase%5Bprint_form%5D=&RepProductForInternalPurchase%5Bis_pdf%5D=&RepProductForInternalPurchase%5Bprint_form%5D=&RepProductForInternalPurchase%5Bis_pdf%5D=&RepProductForInternalPurchase%5Bprint_form%5D=&RepProductForInternalPurchase%5Bis_pdf%5D=&export=true'


def get_remains_to_complete_url():
    return 'https://wms.vseinstrumenti.ru/Report/repProductRest/generate?RepProductRest%5BexportToFile%5D%5Bmethod%5D=&RepProductRest%5BexportToFile%5D%5Bemails%5D%5B%5D=&layout=&RepProductRest%5Bdate_time%5D=&presentation_RepProductRest%5Bdate_time%5D=&RepProductRest%5Borganization%5D=&RepProductRest%5Borganization_type_id%5D=30&RepProductRest%5Borganization_id%5D=&RepProductRest%5Bproduct_type%5D=&RepProductRest%5Bproduct_type_type_id%5D=12&RepProductRest%5Bproduct_type_id%5D=&RepProductRest%5Bvendor%5D=&RepProductRest%5Bvendor_type_id%5D=11&RepProductRest%5Bvendor_id%5D=&RepProductRest%5Bbase_zone%5D=СПБ+-+РЦ+Шушары+Бадаевское&RepProductRest%5Bbase_zone_id%5D=65302&RepProductRest%5Bzones%5D=СПБ+-+Столы+комплектации+ОС%2C+СПБ+-+Столы+комплектации+РМ%2BОС%2C+СПБ+-+Столы+комплектации+Линии+доставки&RepProductRest%5Bzones_type_id%5D=26&RepProductRest%5Bzone_ids%5D=65315%2C65314%2C77056&RepProductRest%5Bline%5D=&RepProductRest%5Bcell%5D=&RepProductRest%5Bcell_type_id%5D=27&RepProductRest%5Bcell_id%5D=&RepProductRest%5Bcontainer%5D=&RepProductRest%5Bcontainer_type_id%5D=29&RepProductRest%5Bcontainer_id%5D=&RepProductRest%5Bquality%5D=&RepProductRest%5Bquality_id%5D=&RepProductRest%5Bnomenclature%5D=&RepProductRest%5Bnomenclature_type_id%5D=13&RepProductRest%5Bnomenclature_id%5D=&RepProductRest%5Bshipment_order%5D=&RepProductRest%5Bshipment_order_type_id%5D=167&RepProductRest%5Bshipment_order_id%5D=&RepProductRest%5Bcategory%5D=&RepProductRest%5Bcategory_type_id%5D=14&RepProductRest%5Bcategory_id%5D=&RepProductRest%5Bbatch_accounting%5D=&RepProductRest%5Bbatch_accounting_id%5D=&RepProductRest%5Bbarcode%5D=&RepProductRest%5BshipmentCell%5D=&RepProductRest%5BshipmentCellId_type_id%5D=27&RepProductRest%5BshipmentCellId%5D=&RepProductRest%5BplanSelectionDateMore%5D=&presentation_RepProductRest%5BplanSelectionDateMore%5D=&RepProductRest%5BplanSelectionDateLess%5D=&presentation_RepProductRest%5BplanSelectionDateLess%5D=&RepProductRest%5Bprint_form%5D=&RepProductRest%5Bis_pdf%5D=&RepProductRest%5Bcolumn_setting%5D=%7B%22zone_name%22%3A323%2C%22cell_name%22%3A191%2C%22container_name%22%3A85%2C%22order_name%22%3A142%2C%22acceptance_act%22%3A97%2C%22sku_name%22%3A692%2C%22quality_name%22%3A80%2C%22quantity%22%3A50%2C%22purchase_price%22%3A335%2C%22tableWidth%22%3A2039%7D&RepProductRest%5Bvisible_columns%5D%5B%5D=quantity&RepProductRest%5Bvisible_columns%5D%5B%5D=cell_name&RepProductRest%5Bvisible_columns%5D%5B%5D=zone_name&RepProductRest%5Bvisible_columns%5D%5B%5D=container_name&RepProductRest%5Bvisible_columns%5D%5B%5D=accounting_model&RepProductRest%5Bprint_form%5D=&RepProductRest%5Bis_pdf%5D=&export=true'


from datetime import datetime, timedelta

def get_remains_for_selection_url():
    # Вычисляем сегодняшнюю и завтрашнюю даты
    today = datetime.now()
    tomorrow = today + timedelta(days=1)

    # Форматы дат для вставки в URL
    iso_today = today.strftime("%Y-%m-%d")
    iso_tomorrow = tomorrow.strftime("%Y-%m-%d")
    pres_today = today.strftime("%d.%m.%Y")
    pres_tomorrow = tomorrow.strftime("%d.%m.%Y")

    # Формат с временем и URL‑кодированием двоеточий
    raw_dt = today.strftime("%Y-%m-%d+%H:%M:%S")
    datetime_param = raw_dt.replace(":", "%3A")

    # Собираем полный URL с динамическими датами
    return (
        "https://wms.vseinstrumenti.ru/Report/repTaskControl/generate?"
        f"layout="
        f"&RepTaskControl%5Bdate_time%5D={datetime_param}"
        f"&RepTaskControl%5Bpriority_id%5D="
        f"&RepTaskControl%5Bbase_zone%5D=%D0%A1%D0%9F%D0%91+-+%D0%A0%D0%A6+%D0%A8%D1%83%D1%88%D0%B0%D1%80%D1%8B+%D0%91%D0%B0%D0%B4%D0%B0%D0%B5%D0%B2%D1%81%D0%BA%D0%BE%D0%B5"
        f"&RepTaskControl%5Bbase_zone_type_id%5D=26"
        f"&RepTaskControl%5Bbase_zone_id%5D=65302"
        f"&RepTaskControl%5Bperiod_start_date%5D={iso_today}"
        f"&presentation_RepTaskControl%5Bperiod_start_date%5D={pres_today}"
        f"&RepTaskControl%5Bperiod_end_date%5D={iso_tomorrow}"
        f"&presentation_RepTaskControl%5Bperiod_end_date%5D={pres_tomorrow}"
        f"&RepTaskControl%5Bperiod_start%5D={iso_today}+00%3A00%3A00"
        f"&RepTaskControl%5Bperiod_end%5D={iso_tomorrow}+00%3A00%3A00"
        f"&RepTaskControl%5Btask_type_id%5D=%D0%9E%D1%82%D0%B1%D0%BE%D1%80"
        f"&RepTaskControl%5Bstream%5D="
        f"&RepTaskControl%5Bstream_type_id%5D=78"
        f"&RepTaskControl%5Bstream_id%5D="
        f"&RepTaskControl%5Bshipment_zone%5D="
        f"&RepTaskControl%5Bshipment_zone_type_id%5D=26"
        f"&RepTaskControl%5Bshipment_zone_id%5D="
        f"&RepTaskControl%5Bshipment_cell%5D="
        f"&RepTaskControl%5Bshipment_cell_type_id%5D=27"
        f"&RepTaskControl%5Bshipment_cell_id%5D="
        f"&RepTaskControl%5Bshipment_cell_ids%5D="
        f"&RepTaskControl%5Bexclude_finished_tasks%5D=0"
        f"&RepTaskControl%5Bexclude_finished_tasks%5D=1"
        f"&RepTaskControl%5Bprint_all%5D=0"
        f"&RepTaskControl%5Bto_print%5D="
        f"&RepTaskControl%5Bis_clear_tabs%5D="
        f"&RepTaskControl%5Bis_delivery_line%5D=0"
        f"&RepTaskControl%5Breplace_tabs%5D="
        f"&RepTaskControl%5Bcurrent_tab%5D="
        f"&RepTaskControl%5Bcurrent_range_time%5D=00%3A00-00%3A00"
        f"&RepTaskControl%5Brange_times%5D=%5B%2200%3A00-06%3A00%22%2C%2212%3A00-18%3A00%22%2C%2200%3A00-00%3A00%22%2C%2206%3A00-12%3A00%22%2C%2218%3A00-00%3A00%22%2C%2210%3A00-22%3A00%22%5D"
        f"&RepTaskControl%5Bis_executor_assigned%5D=0"
        f"&RepTaskControl%5BisNeedBlockedTasks%5D=0"
        f"&RepTaskControl%5BtaskCount%5D=0"
        f"&presentation_RepTaskControl%5BtaskCount%5D=0"
        f"&RepTaskControl%5Binterval%5D="
        f"&RepTaskControl%5BshipmentOrder%5D="
        f"&RepTaskControl%5BshipmentOrderId_type_id%5D=167"
        f"&RepTaskControl%5BshipmentOrderId%5D="
        f"&RepTaskControl%5BcellLine%5D="
        f"&RepTaskControl%5Bprint_form%5D="
        f"&RepTaskControl%5Bis_pdf%5D="
        f"&RepTaskControl%5Bvisible_columns%5D%5B%5D=date_time"
        f"&RepTaskControl%5Bvisible_columns%5D%5B%5D=id"
        f"&RepTaskControl%5Bvisible_columns%5D%5B%5D=comment"
        f"&RepTaskControl%5Bvisible_columns%5D%5B%5D=type_name"
        f"&RepTaskControl%5Bvisible_columns%5D%5B%5D=stream_name"
        f"&RepTaskControl%5Bvisible_columns%5D%5B%5D=executor_id"
        f"&RepTaskControl%5Bvisible_columns%5D%5B%5D=priority_id"
        f"&RepTaskControl%5Bvisible_columns%5D%5B%5D=cell_name"
        f"&RepTaskControl%5Bvisible_columns%5D%5B%5D=rows_count"
        f"&RepTaskControl%5Bvisible_columns%5D%5B%5D=task_rows_count"
        f"&RepTaskControl%5Bvisible_columns%5D%5B%5D=is_all_shipment_cells_printed"
        f"&button=export"
    )



def get_movement_rpkd_url():
    return 'https://wms.vseinstrumenti.ru/Report/repMovement/generate?RepMovement%5BexportToFile%5D%5Bmethod%5D=&RepMovement%5BexportToFile%5D%5Bemails%5D%5B%5D=&layout=&RepMovement%5Btype%5D=movement&RepMovement%5Bperiod_start%5D=2025-03-25+10%3A00%3A00&presentation_RepMovement%5Bperiod_start%5D=25.03.2025+10%3A00%3A00&RepMovement%5Bperiod_end%5D=2025-03-25+23%3A59%3A59&presentation_RepMovement%5Bperiod_end%5D=25.03.2025+23%3A59%3A59&RepMovement%5Bbase_zone%5D=%D0%A1%D0%9F%D0%91+-+%D0%A0%D0%A6+%D0%A8%D1%83%D1%88%D0%B0%D1%80%D1%8B+%D0%91%D0%B0%D0%B4%D0%B0%D0%B5%D0%B2%D1%81%D0%BA%D0%BE%D0%B5&RepMovement%5Bbase_zone_type_id%5D=26&RepMovement%5Bbase_zone_id%5D=65302&RepMovement%5BsourceZones%5D=%D0%A1%D0%9F%D0%91+-+%D0%A1%D1%82%D0%BE%D0%BB%D1%8B+%D0%BA%D0%BE%D0%BC%D0%BF%D0%BB%D0%B5%D0%BA%D1%82%D0%B0%D1%86%D0%B8%D0%B8+%D0%9B%D0%B8%D0%BD%D0%B8%D0%B8+%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BA%D0%B8&RepMovement%5BsourceZoneIds_type_id%5D=26&RepMovement%5BsourceZoneIds%5D=77056&RepMovement%5Btarget_zone%5D=%D0%A1%D0%9F%D0%91+-+%D0%A1%D1%82%D0%BE%D0%BB%D1%8B+%D0%BA%D0%BE%D0%BC%D0%BF%D0%BB%D0%B5%D0%BA%D1%82%D0%B0%D1%86%D0%B8%D0%B8+%D0%9B%D0%B8%D0%BD%D0%B8%D0%B8+%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BA%D0%B8&RepMovement%5Btarget_zone_type_id%5D=26&RepMovement%5Btarget_zone_id%5D=77056&RepMovement%5Bsource_cell%5D=&RepMovement%5Bsource_cell_type_id%5D=27&RepMovement%5Bsource_cell_id%5D=&RepMovement%5Btarget_cell%5D=&RepMovement%5Btarget_cell_type_id%5D=27&RepMovement%5Btarget_cell_id%5D=&RepMovement%5Bshipment_order%5D=&RepMovement%5Bshipment_order_type_id%5D=167&RepMovement%5Bshipment_order_id%5D=&RepMovement%5Bshipment_cell%5D=&RepMovement%5Bshipment_cell_type_id%5D=27&RepMovement%5Bshipment_cell_id%5D=&RepMovement%5Bquality%5D=&RepMovement%5Bquality_id%5D=&RepMovement%5Bexecutor%5D=&RepMovement%5Bexecutor_type_id%5D=7&RepMovement%5Bexecutor_id%5D=&RepMovement%5Bonly_with_task%5D=0&RepMovement%5BisPlacementByContainer%5D=0&RepMovement%5Bprint_form%5D=&RepMovement%5Bis_pdf%5D=&RepMovement%5Bcolumn_setting%5D=&RepMovement%5Bvisible_columns%5D%5B%5D=movement_datetime&RepMovement%5Bvisible_columns%5D%5B%5D=shipment_cell_name&RepMovement%5Bvisible_columns%5D%5B%5D=nomenclature_name&RepMovement%5Bvisible_columns%5D%5B%5D=executor_name&RepMovement%5Bvisible_columns%5D%5B%5D=quantity&RepMovement%5Bvisible_columns%5D%5B%5D=accounting_model_name&RepMovement%5Bvisible_columns%5D%5B%5D=target_zone_name&RepMovement%5Bvisible_columns%5D%5B%5D=shipment_order_id&RepProductRest%5Bprint_form%5D=&RepProductRest%5Bis_pdf%5D=&export=true'


def get_movement_shops_regions_url():
    return 'https://wms.vseinstrumenti.ru/Report/repMovement/generate?RepMovement%5BexportToFile%5D%5Bmethod%5D=&RepMovement%5BexportToFile%5D%5Bemails%5D%5B%5D=&layout=&RepMovement%5Btype%5D=movement&RepMovement%5Bperiod_start%5D=2025-03-25+10%3A00%3A00&presentation_RepMovement%5Bperiod_start%5D=25.03.2025+10%3A00%3A00&RepMovement%5Bperiod_end%5D=2025-03-25+23%3A59%3A59&presentation_RepMovement%5Bperiod_end%5D=25.03.2025+23%3A59%3A59&RepMovement%5Bbase_zone%5D=%D0%A1%D0%9F%D0%91+-+%D0%A0%D0%A6+%D0%A8%D1%83%D1%88%D0%B0%D1%80%D1%8B+%D0%91%D0%B0%D0%B4%D0%B0%D0%B5%D0%B2%D1%81%D0%BA%D0%BE%D0%B5&RepMovement%5Bbase_zone_type_id%5D=26&RepMovement%5Bbase_zone_id%5D=65302&RepMovement%5BsourceZones%5D=%D0%A1%D0%9F%D0%91+-+%D0%A1%D1%82%D0%BE%D0%BB%D1%8B+%D0%BA%D0%BE%D0%BC%D0%BF%D0%BB%D0%B5%D0%BA%D1%82%D0%B0%D1%86%D0%B8%D0%B8+%D0%A0%D0%9C%2B%D0%9E%D0%A1&RepMovement%5BsourceZoneIds_type_id%5D=26&RepMovement%5BsourceZoneIds%5D=65315&RepMovement%5Btarget_zone%5D=%D0%A1%D0%9F%D0%91+-+%D0%A1%D1%82%D0%BE%D0%BB%D1%8B+%D0%BA%D0%BE%D0%BC%D0%BF%D0%BB%D0%B5%D0%BA%D1%82%D0%B0%D1%86%D0%B8%D0%B8+%D0%A0%D0%9C%2B%D0%9E%D0%A1&RepMovement%5Btarget_zone_type_id%5D=26&RepMovement%5Btarget_zone_id%5D=65315&RepMovement%5Bsource_cell%5D=&RepMovement%5Bsource_cell_type_id%5D=27&RepMovement%5Bsource_cell_id%5D=&RepMovement%5Btarget_cell%5D=&RepMovement%5Btarget_cell_type_id%5D=27&RepMovement%5Btarget_cell_id%5D=&RepMovement%5Bshipment_order%5D=&RepMovement%5Bshipment_order_type_id%5D=167&RepMovement%5Bshipment_order_id%5D=&RepMovement%5Bshipment_cell%5D=&RepMovement%5Bshipment_cell_type_id%5D=27&RepMovement%5Bshipment_cell_id%5D=&RepMovement%5Bquality%5D=&RepMovement%5Bquality_id%5D=&RepMovement%5Bexecutor%5D=&RepMovement%5Bexecutor_type_id%5D=7&RepMovement%5Bexecutor_id%5D=&RepMovement%5Bonly_with_task%5D=0&RepMovement%5BisPlacementByContainer%5D=0&RepMovement%5Bprint_form%5D=&RepMovement%5Bis_pdf%5D=&RepMovement%5Bcolumn_setting%5D=&RepMovement%5Bvisible_columns%5D%5B%5D=movement_datetime&RepMovement%5Bvisible_columns%5D%5B%5D=shipment_cell_name&RepMovement%5Bvisible_columns%5D%5B%5D=nomenclature_name&RepMovement%5Bvisible_columns%5D%5B%5D=executor_name&RepMovement%5Bvisible_columns%5D%5B%5D=quantity&RepMovement%5Bvisible_columns%5D%5B%5D=accounting_model_name&RepMovement%5Bvisible_columns%5D%5B%5D=target_zone_name&RepMovement%5Bvisible_columns%5D%5B%5D=shipment_order_id&RepProductRest%5Bprint_form%5D=&RepProductRest%5Bis_pdf%5D=&export=true'


def get_container_close_rpkd_url():
    return 'https://wms.vseinstrumenti.ru/Report/repMovement/generate?RepMovement%5BexportToFile%5D%5Bmethod%5D=&RepMovement%5BexportToFile%5D%5Bemails%5D%5B%5D=&layout=&RepMovement%5Btype%5D=movement&RepMovement%5Bperiod_start%5D=2025-03-25+10%3A00%3A00&presentation_RepMovement%5Bperiod_start%5D=25.03.2025+10%3A00%3A00&RepMovement%5Bperiod_end%5D=2025-03-25+23%3A59%3A59&presentation_RepMovement%5Bperiod_end%5D=25.03.2025+23%3A59%3A59&RepMovement%5Bbase_zone%5D=%D0%A1%D0%9F%D0%91+-+%D0%A0%D0%A6+%D0%A8%D1%83%D1%88%D0%B0%D1%80%D1%8B+%D0%91%D0%B0%D0%B4%D0%B0%D0%B5%D0%B2%D1%81%D0%BA%D0%BE%D0%B5&RepMovement%5Bbase_zone_type_id%5D=26&RepMovement%5Bbase_zone_id%5D=65302&RepMovement%5BsourceZones%5D=%D0%A1%D0%9F%D0%91+-+%D0%A1%D1%82%D0%BE%D0%BB%D1%8B+%D0%BA%D0%BE%D0%BC%D0%BF%D0%BB%D0%B5%D0%BA%D1%82%D0%B0%D1%86%D0%B8%D0%B8+%D0%9B%D0%B8%D0%BD%D0%B8%D0%B8+%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BA%D0%B8&RepMovement%5BsourceZoneIds_type_id%5D=26&RepMovement%5BsourceZoneIds%5D=77056&RepMovement%5Btarget_zone%5D=002+%D0%98%D1%81%D1%85%D0%BE%D0%B4%D1%8F%D1%89%D0%B8%D0%B9+%D0%B1%D1%83%D1%84%D0%B5%D1%80+%D0%BA%D0%BE%D0%BC%D0%BF%D0%BB%D0%B5%D0%BA%D1%82%D0%B0%D1%86%D0%B8%D0%B8+%D0%A0%D0%9F%D0%9A%D0%94+%D0%A1%D0%9F%D0%91&RepMovement%5Btarget_zone_type_id%5D=26&RepMovement%5Btarget_zone_id%5D=77057&RepMovement%5Bsource_cell%5D=&RepMovement%5Bsource_cell_type_id%5D=27&RepMovement%5Bsource_cell_id%5D=&RepMovement%5Btarget_cell%5D=&RepMovement%5Btarget_cell_type_id%5D=27&RepMovement%5Btarget_cell_id%5D=&RepMovement%5Bshipment_order%5D=&RepMovement%5Bshipment_order_type_id%5D=167&RepMovement%5Bshipment_order_id%5D=&RepMovement%5Bshipment_cell%5D=&RepMovement%5Bshipment_cell_type_id%5D=27&RepMovement%5Bshipment_cell_id%5D=&RepMovement%5Bquality%5D=&RepMovement%5Bquality_id%5D=&RepMovement%5Bexecutor%5D=&RepMovement%5Bexecutor_type_id%5D=7&RepMovement%5Bexecutor_id%5D=&RepMovement%5Bonly_with_task%5D=0&RepMovement%5BisPlacementByContainer%5D=0&RepMovement%5Bprint_form%5D=&RepMovement%5Bis_pdf%5D=&RepMovement%5Bcolumn_setting%5D=&RepMovement%5Bvisible_columns%5D%5B%5D=movement_datetime&RepMovement%5Bvisible_columns%5D%5B%5D=executor_name&RepMovement%5Bvisible_columns%5D%5B%5D=target_container_name&RepProductRest%5Bprint_form%5D=&RepProductRest%5Bis_pdf%5D=&export=true'


def get_container_close_shops_regions_url():
    return 'https://wms.vseinstrumenti.ru/Report/repMovement/generate?RepMovement%5BexportToFile%5D%5Bmethod%5D=&RepMovement%5BexportToFile%5D%5Bemails%5D%5B%5D=&layout=&RepMovement%5Btype%5D=movement&RepMovement%5Bperiod_start%5D=2025-03-25+10%3A00%3A00&presentation_RepMovement%5Bperiod_start%5D=25.03.2025+10%3A00%3A00&RepMovement%5Bperiod_end%5D=2025-03-25+23%3A59%3A59&presentation_RepMovement%5Bperiod_end%5D=25.03.2025+23%3A59%3A59&RepMovement%5Bbase_zone%5D=%D0%A1%D0%9F%D0%91+-+%D0%A0%D0%A6+%D0%A8%D1%83%D1%88%D0%B0%D1%80%D1%8B+%D0%91%D0%B0%D0%B4%D0%B0%D0%B5%D0%B2%D1%81%D0%BA%D0%BE%D0%B5&RepMovement%5Bbase_zone_type_id%5D=26&RepMovement%5Bbase_zone_id%5D=65302&RepMovement%5BsourceZones%5D=%D0%A1%D0%9F%D0%91+-+%D0%A1%D1%82%D0%BE%D0%BB%D1%8B+%D0%BA%D0%BE%D0%BC%D0%BF%D0%BB%D0%B5%D0%BA%D1%82%D0%B0%D1%86%D0%B8%D0%B8+%D0%A0%D0%9C%2B%D0%9E%D0%A1&RepMovement%5BsourceZoneIds_type_id%5D=26&RepMovement%5BsourceZoneIds%5D=65315&RepMovement%5Btarget_zone%5D=010+%D0%9F%D0%BE%D0%B4%D0%B3%D0%BE%D1%82%D0%BE%D0%B2%D0%BA%D0%B0+%D0%BA+%D0%BE%D1%82%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B5+%D0%A1%D0%9F%D0%91&RepMovement%5Btarget_zone_type_id%5D=26&RepMovement%5Btarget_zone_id%5D=75097&RepMovement%5Bsource_cell%5D=&RepMovement%5Bsource_cell_type_id%5D=27&RepMovement%5Bsource_cell_id%5D=&RepMovement%5Btarget_cell%5D=&RepMovement%5Btarget_cell_type_id%5D=27&RepMovement%5Btarget_cell_id%5D=&RepMovement%5Bshipment_order%5D=&RepMovement%5Bshipment_order_type_id%5D=167&RepMovement%5Bshipment_order_id%5D=&RepMovement%5Bshipment_cell%5D=&RepMovement%5Bshipment_cell_type_id%5D=27&RepMovement%5Bshipment_cell_id%5D=&RepMovement%5Bquality%5D=&RepMovement%5Bquality_id%5D=&RepMovement%5Bexecutor%5D=&RepMovement%5Bexecutor_type_id%5D=7&RepMovement%5Bexecutor_id%5D=&RepMovement%5Bonly_with_task%5D=0&RepMovement%5BisPlacementByContainer%5D=0&RepMovement%5Bprint_form%5D=&RepMovement%5Bis_pdf%5D=&RepMovement%5Bcolumn_setting%5D=&RepMovement%5Bvisible_columns%5D%5B%5D=movement_datetime&RepMovement%5Bvisible_columns%5D%5B%5D=executor_name&RepMovement%5Bvisible_columns%5D%5B%5D=target_container_name&RepProductRest%5Bprint_form%5D=&RepProductRest%5Bis_pdf%5D=&export=true'


def get_picking_url():
    return 'https://wms.vseinstrumenti.ru/Report/repMovement/generate?RepMovement%5BexportToFile%5D%5Bmethod%5D=&RepMovement%5BexportToFile%5D%5Bemails%5D%5B%5D=&layout=&RepMovement%5Btype%5D=picking&RepMovement%5Bperiod_start%5D=2025-03-27+10%3A00%3A00&presentation_RepMovement%5Bperiod_start%5D=27.03.2025+10%3A00%3A00&RepMovement%5Bperiod_end%5D=2025-03-27+23%3A59%3A59&presentation_RepMovement%5Bperiod_end%5D=27.03.2025+23%3A59%3A59&RepMovement%5Bbase_zone%5D=СПБ+-+РЦ+Шушары+Бадаевское&RepMovement%5Bbase_zone_type_id%5D=26&RepMovement%5Bbase_zone_id%5D=65302&RepMovement%5BsourceZones%5D=&RepMovement%5BsourceZoneIds_type_id%5D=26&RepMovement%5BsourceZoneIds%5D=&RepMovement%5Btarget_zone%5D=&RepMovement%5Btarget_zone_type_id%5D=26&RepMovement%5Btarget_zone_id%5D=&RepMovement%5Bsource_cell%5D=&RepMovement%5Bsource_cell_type_id%5D=27&RepMovement%5Bsource_cell_id%5D=&RepMovement%5Btarget_cell%5D=&RepMovement%5Btarget_cell_type_id%5D=27&RepMovement%5Btarget_cell_id%5D=&RepMovement%5Bshipment_order%5D=&RepMovement%5Bshipment_order_type_id%5D=167&RepMovement%5Bshipment_order_id%5D=&RepMovement%5Bshipment_cell%5D=&RepMovement%5Bshipment_cell_type_id%5D=27&RepMovement%5Bshipment_cell_id%5D=&RepMovement%5Bquality%5D=&RepMovement%5Bquality_id%5D=&RepMovement%5Bexecutor%5D=&RepMovement%5Bexecutor_type_id%5D=7&RepMovement%5Bexecutor_id%5D=&RepMovement%5Bonly_with_task%5D=0&RepMovement%5BisPlacementByContainer%5D=0&RepMovement%5Bprint_form%5D=&RepMovement%5Bis_pdf%5D=&RepMovement%5Bcolumn_setting%5D=&RepMovement%5Bvisible_columns%5D%5B%5D=accounting_model_name&RepMovement%5Bvisible_columns%5D%5B%5D=executor_name&RepMovement%5Bvisible_columns%5D%5B%5D=movement_datetime&RepMovement%5Bvisible_columns%5D%5B%5D=source_zone_name&RepMovement%5Bvisible_columns%5D%5B%5D=quantity&RepMovement%5Bvisible_columns%5D%5B%5D=shipment_cell_name&RepProductRest%5Bprint_form%5D=&RepProductRest%5Bis_pdf%5D=&export=true'


def process_operations(operations=None):
    if operations is None:
        operations = ["remains_rpkd_domodedovo", "remains_rpkd_chashnikovo", "remains_to_complete",
                      "remains_for_selection", "movement_rpkd", "movement_shops_regions",
                      "container_close_rpkd", "container_close_shops_regions", "picking"]
    username, password, date_str = get_credentials_and_date(excel_file, "Настройки")
    print(f"Используемая дата: {date_str}")
    model_dict, model5_dict, zones_dict = {}, {}, {}
    try:
        model_dict = load_dict(excel_file, "2МУ")
        model5_dict = load_dict(excel_file, "5МУ")
        zones_dict = load_zones_dict(excel_file)
    except Exception as e:
        print(f"Примечание: Не удалось загрузить словари: {e}")
    rates = load_rates(excel_file)
    sess = authenticate(username, password)
    dataframes = {}
    combined_rpkd_df = None
    need_process_domodedovo = "remains_rpkd_domodedovo" in operations
    need_process_chashnikovo = "remains_rpkd_chashnikovo" in operations
    if need_process_domodedovo or need_process_chashnikovo:
        rpkd_dataframes = []
        if need_process_domodedovo:
            try:
                print("\n=== Обработка операции: remains_rpkd_domodedovo ===")
                url = get_remains_rpkd_domodedovo_url()
                updated_url = update_dates(url, date_str, "remains_rpkd_domodedovo")
                df_domodedovo = download_and_process_csv(updated_url, "remains_rpkd_domodedovo", sess, model_dict, model5_dict)
                if df_domodedovo is not None and not df_domodedovo.empty:
                    rpkd_dataframes.append(df_domodedovo)
            except Exception as e:
                print(f"Ошибка при обработке операции remains_rpkd_domodedovo: {e}")
        if need_process_chashnikovo:
            try:
                print("\n=== Обработка операции: remains_rpkd_chashnikovo ===")
                url = get_remains_rpkd_chashnikovo_url()
                updated_url = update_dates(url, date_str, "remains_rpkd_chashnikovo")
                df_chashnikovo = download_and_process_csv(updated_url, "remains_rpkd_chashnikovo", sess, model_dict, model5_dict)
                if df_chashnikovo is not None and not df_chashnikovo.empty:
                    rpkd_dataframes.append(df_chashnikovo)
            except Exception as e:
                print(f"Ошибка при обработке операции remains_rpkd_chashnikovo: {e}")
        if rpkd_dataframes:
            combined_rpkd_df = pd.concat(rpkd_dataframes, ignore_index=True)
            process_csv_and_save("Отстатки_РПКД", excel_file, combined_rpkd_df, rates)
            dataframes["Отстатки_РПКД"] = combined_rpkd_df
    remaining_operations = [op for op in operations if op not in ["remains_rpkd_domodedovo", "remains_rpkd_chashnikovo"]]
    for operation in remaining_operations:
        print(f"\n=== Обработка операции: {operation} ===")
        try:
            if operation == "remains_to_complete":
                url = get_remains_to_complete_url()
                df = download_and_process_csv(url, operation, sess, model_dict, model5_dict)
                if df is not None and not df.empty:
                    process_csv_and_save("Осталось_Закомплектовать", excel_file, df, rates)
                    dataframes["Осталось_Закомплектовать"] = df
            elif operation == "remains_for_selection":
                url = get_remains_for_selection_url()
                updated_url = update_dates(url, date_str, operation)
                df = download_and_process_csv(updated_url, operation, sess, model_dict, model5_dict)
                if df is not None and not df.empty:
                    process_csv_and_save("Осталось_На_Отборе", excel_file, df, rates)
                    dataframes["Осталось_На_Отборе"] = df
            elif operation == "movement_rpkd":
                url = get_movement_rpkd_url()
                updated_url = update_dates(url, date_str, operation)
                df = download_and_process_csv(updated_url, operation, sess, model_dict, model5_dict)
                if df is not None and not df.empty:
                    process_csv_and_save("Комплектация_РПКД", excel_file, df, rates)
                    dataframes["Комплектация_РПКД"] = df
            elif operation == "movement_shops_regions":
                url = get_movement_shops_regions_url()
                updated_url = update_dates(url, date_str, operation)
                df = download_and_process_csv(updated_url, operation, sess, model_dict, model5_dict)
                if df is not None and not df.empty:
                    process_csv_and_save("Комплектация_Магазы_Реги", excel_file, df, rates)
                    dataframes["Комплектация_Магазы_Реги"] = df
            elif operation == "container_close_rpkd":
                url = get_container_close_rpkd_url()
                updated_url = update_dates(url, date_str, operation)
                df = download_and_process_csv(updated_url, operation, sess, model_dict, model5_dict)
                if df is not None and not df.empty:
                    process_csv_and_save("Закрытие_контейнера_РПКД", excel_file, df, rates)
                    dataframes["Закрытие_контейнера_РПКД"] = df
            elif operation == "container_close_shops_regions":
                url = get_container_close_shops_regions_url()
                updated_url = update_dates(url, date_str, operation)
                df = download_and_process_csv(updated_url, operation, sess, model_dict, model5_dict)
                if df is not None and not df.empty:
                    process_csv_and_save("Закрытие_контейнера_Магазы_Реги", excel_file, df, rates)
                    dataframes["Закрытие_контейнера_Магазы_Реги"] = df
            elif operation == "picking":
                url = get_picking_url()
                updated_url = update_dates(url, date_str, operation)
                df = download_and_process_csv(updated_url, operation, sess, model_dict, model5_dict, rates, zones_dict)
                if df is not None and not df.empty:
                    process_csv_and_save("Сделано_Отбор", excel_file, df, rates, zones_dict, model5_dict)
                    dataframes["Сделано_Отбор"] = df
        except Exception as e:
            print(f"Ошибка при обработке операции {operation}: {e}")


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description='Process warehouse shipment operations')
    parser.add_argument('--operations', nargs='+',
                        choices=['remains_rpkd_domodedovo', 'remains_rpkd_chashnikovo',
                                 'remains_to_complete', 'remains_for_selection',
                                 'movement_rpkd', 'movement_shops_regions',
                                 'container_close_rpkd', 'container_close_shops_regions',
                                 'picking', 'all'],
                        default=['all'], help='Operations to process')
    args = parser.parse_args()

    # Если указан параметр "all", то обрабатываются все операции
    if 'all' in args.operations:
        operations_to_process = [
            "remains_rpkd_domodedovo",
            "remains_rpkd_chashnikovo",
            "remains_to_complete",
            "remains_for_selection",
            "movement_rpkd",
            "movement_shops_regions",
            "container_close_rpkd",
            "container_close_shops_regions",
            "picking"
        ]
    else:
        operations_to_process = args.operations

    # Записываем текущее время (ЧЧ:ММ) в ячейку K2 листа "Главная"
    write_current_time_to_main(excel_file)

    try:
        process_operations(operations_to_process)
        print("Все операции обработаны успешно!")
    except Exception as e:
        print(f"Произошла ошибка: {e}")
        raise
